# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod types { pub mod types { pub mod identifier { # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: types :: identifier :: IdentifierBytes32\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentifierBytes32 (* mut [u8 ; 32] ,) ; impl ferment_interfaces :: FFIConversion < crate :: types :: identifier :: IdentifierBytes32 > for IdentifierBytes32 { unsafe fn ffi_from_const (ffi : * const IdentifierBytes32) -> crate :: types :: identifier :: IdentifierBytes32 { let ffi_ref = & * ffi ; crate :: types :: identifier :: IdentifierBytes32 (* ffi_ref . 0 ,) } unsafe fn ffi_to_const (obj : crate :: types :: identifier :: IdentifierBytes32) -> * const IdentifierBytes32 { ferment_interfaces :: boxed (IdentifierBytes32 (ferment_interfaces :: boxed (obj . 0) ,)) } unsafe fn destroy (ffi : * mut IdentifierBytes32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentifierBytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentifierBytes32_ctor (o_0 : * mut [u8 ; 32]) -> * mut IdentifierBytes32 { ferment_interfaces :: boxed (IdentifierBytes32 (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentifierBytes32_destroy (ffi : * mut IdentifierBytes32) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: types :: identifier :: Identifier\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Identifier (* mut crate :: fermented :: types :: types :: identifier :: IdentifierBytes32 ,) ; impl ferment_interfaces :: FFIConversion < crate :: types :: identifier :: Identifier > for Identifier { unsafe fn ffi_from_const (ffi : * const Identifier) -> crate :: types :: identifier :: Identifier { let ffi_ref = & * ffi ; crate :: types :: identifier :: Identifier (ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) ,) } unsafe fn ffi_to_const (obj : crate :: types :: identifier :: Identifier) -> * const Identifier { ferment_interfaces :: boxed (Identifier (ferment_interfaces :: FFIConversion :: ffi_to (obj . 0) ,)) } unsafe fn destroy (ffi : * mut Identifier) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Identifier { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identifier_ctor (o_0 : * mut crate :: fermented :: types :: types :: identifier :: IdentifierBytes32) -> * mut Identifier { ferment_interfaces :: boxed (Identifier (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identifier_destroy (ffi : * mut Identifier) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod binary_data { # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: types :: binary_data :: BinaryData\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct BinaryData (* mut crate :: fermented :: generics :: Vec_u8 ,) ; impl ferment_interfaces :: FFIConversion < crate :: types :: binary_data :: BinaryData > for BinaryData { unsafe fn ffi_from_const (ffi : * const BinaryData) -> crate :: types :: binary_data :: BinaryData { let ffi_ref = & * ffi ; crate :: types :: binary_data :: BinaryData (ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) ,) } unsafe fn ffi_to_const (obj : crate :: types :: binary_data :: BinaryData) -> * const BinaryData { ferment_interfaces :: boxed (BinaryData (ferment_interfaces :: FFIConversion :: ffi_to (obj . 0) ,)) } unsafe fn destroy (ffi : * mut BinaryData) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for BinaryData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn BinaryData_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut BinaryData { ferment_interfaces :: boxed (BinaryData (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn BinaryData_destroy (ffi : * mut BinaryData) { ferment_interfaces :: unbox_any (ffi) ; } } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod generics { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 , } impl ferment_interfaces :: FFIConversion < Vec < u8 > > for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { ferment_interfaces :: FFIVecConversion :: decode (& * ffi) } unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_u8) { ferment_interfaces :: unbox_any (ffi) ; ; } } impl ferment_interfaces :: FFIVecConversion for Vec_u8 { type Value = Vec < u8 > ; unsafe fn decode (& self) -> Self :: Value { ferment_interfaces :: from_primitive_vec (self . values , self . count) } unsafe fn encode (obj : Self :: Value) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } }