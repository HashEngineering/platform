# [allow (dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables)] pub mod types { pub mod types { pub mod binary_data { use crate :: types :: binary_data :: BinaryData ; use crate :: fermented :: generics :: Vec_u8_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the BinaryData\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct BinaryData_FFI (* mut Vec_u8_FFI ,) ; impl ferment_interfaces :: FFIConversion < BinaryData > for BinaryData_FFI { unsafe fn ffi_from_const (ffi : * const BinaryData_FFI) -> BinaryData { let ffi_ref = & * ffi ; BinaryData ({ let vec = & * ffi_ref . 0 ; { let vec = vec ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) } } ,) } unsafe fn ffi_to_const (obj : BinaryData) -> * const BinaryData_FFI { ferment_interfaces :: boxed (BinaryData_FFI (ferment_interfaces :: FFIConversion :: ffi_to (obj . 0) ,)) } unsafe fn destroy (ffi : * mut BinaryData_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for BinaryData_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn BinaryData_FFI_destroy (ffi : * mut BinaryData_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } } # [allow (dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables)] pub mod generics { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_u8_FFI { pub count : usize , pub values : * mut u8 , } impl ferment_interfaces :: FFIConversion < Vec < u8 >> for Vec_u8_FFI { unsafe fn ffi_from_const (ffi : * const Vec_u8_FFI) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_u8_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_u8_FFI { type Value = u8 ; unsafe fn decode (& self) -> Vec < Self :: Value > { ferment_interfaces :: from_simple_vec (self . values as * const Self :: Value , self . count) } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_u8_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } }