# [allow (dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables)] pub mod types { pub mod identity { pub mod identity { use crate :: fermented :: types :: identity :: v0 :: IdentityV0_FFI ; use crate :: identity :: v0 :: IdentityV0 ; use crate :: identity :: identity :: Identity ; # [doc = "FFI-representation of the Identity"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum Identity_FFI { V0 (* mut IdentityV0_FFI ,) , } impl ferment_interfaces :: FFIConversion < Identity > for Identity_FFI { unsafe fn ffi_from_const (ffi : * const Identity_FFI) -> Identity { let ffi_ref = & * ffi ; match ffi_ref { Identity_FFI :: V0 (o_0 ,) => Identity :: V0 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , } } unsafe fn ffi_to_const (obj : Identity) -> * const Identity_FFI { ferment_interfaces :: boxed (match obj { Identity :: V0 (o_0 ,) => Identity_FFI :: V0 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , }) } unsafe fn destroy (ffi : * mut Identity_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Identity_FFI { fn drop (& mut self) { unsafe { match self { Identity_FFI :: V0 (o_0 ,) => { < IdentityV0_FFI as ferment_interfaces :: FFIConversion < IdentityV0 >> :: destroy (o_0 . to_owned ()) ; } , } } } } # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identity_FFI_destroy (ffi : * mut Identity_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod v0 { use crate :: identity :: IdentityPublicKey ; use crate :: identity :: KeyID ; use crate :: identity :: v0 :: IdentityV0 ; use crate :: prelude :: Revision ; use crate :: identifier :: Identifier ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI ; use std :: collections :: BTreeMap ; use crate :: fermented :: types :: identifier :: Identifier_FFI ; use crate :: fermented :: types :: identity :: IdentityPublicKey_FFI ; use crate :: fermented :: types :: identity :: KeyID_FFI ; use crate :: fermented :: types :: prelude :: Revision_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the IdentityV0\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentityV0_FFI { pub id : * mut Identifier_FFI , pub public_keys : * mut std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI , pub balance : u64 , pub revision : * mut Revision_FFI , } impl ferment_interfaces :: FFIConversion < IdentityV0 > for IdentityV0_FFI { unsafe fn ffi_from_const (ffi : * const IdentityV0_FFI) -> IdentityV0 { let ffi_ref = & * ffi ; IdentityV0 { id : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . id) , public_keys : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . public_keys) , balance : ffi_ref . balance , revision : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . revision) , } } unsafe fn ffi_to_const (obj : IdentityV0) -> * const IdentityV0_FFI { ferment_interfaces :: boxed (IdentityV0_FFI { id : ferment_interfaces :: FFIConversion :: ffi_to (obj . id) , public_keys : ferment_interfaces :: FFIConversion :: ffi_to (obj . public_keys) , balance : obj . balance , revision : ferment_interfaces :: FFIConversion :: ffi_to (obj . revision) , }) } unsafe fn destroy (ffi : * mut IdentityV0_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityV0_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < Identifier_FFI as ferment_interfaces :: FFIConversion < Identifier >> :: destroy (ffi_ref . id) ; ferment_interfaces :: unbox_any (ffi_ref . public_keys) ; ; { } ; < Revision_FFI as ferment_interfaces :: FFIConversion < Revision >> :: destroy (ffi_ref . revision) ; } } } # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityV0_FFI_destroy (ffi : * mut IdentityV0_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } pub mod prelude { use crate :: prelude :: TimestampMillis ; use crate :: prelude :: Revision ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the TimestampMillis\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct TimestampMillis_FFI (u64 ,) ; impl ferment_interfaces :: FFIConversion < TimestampMillis > for TimestampMillis_FFI { unsafe fn ffi_from_const (ffi : * const TimestampMillis_FFI) -> TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : TimestampMillis) -> * const TimestampMillis_FFI { ferment_interfaces :: boxed (TimestampMillis_FFI (obj)) } unsafe fn destroy (ffi : * mut TimestampMillis_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TimestampMillis_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; } } } # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TimestampMillis_FFI_destroy (ffi : * mut TimestampMillis_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the Revision\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Revision_FFI (u64 ,) ; impl ferment_interfaces :: FFIConversion < Revision > for Revision_FFI { unsafe fn ffi_from_const (ffi : * const Revision_FFI) -> Revision { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : Revision) -> * const Revision_FFI { ferment_interfaces :: boxed (Revision_FFI (obj)) } unsafe fn destroy (ffi : * mut Revision_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Revision_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; } } } # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Revision_FFI_destroy (ffi : * mut Revision_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } # [allow (dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables)] pub mod generics { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: identity :: KeyID_FFI , pub values : * mut * mut crate :: fermented :: types :: identity :: IdentityPublicKey_FFI , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: identity :: KeyID , crate :: identity :: IdentityPublicKey > > for std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI) -> std :: collections :: BTreeMap < crate :: identity :: KeyID , crate :: identity :: IdentityPublicKey > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: identity :: KeyID , crate :: identity :: IdentityPublicKey >) -> * const std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: identity :: KeyID , crate :: fermented :: types :: identity :: KeyID_FFI > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: identity :: IdentityPublicKey , crate :: fermented :: types :: identity :: IdentityPublicKey_FFI > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } }