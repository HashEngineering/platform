# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod types { pub mod identity { pub mod v0 { # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: identity :: v0 :: IdentityV0\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentityV0 { pub id : * mut crate :: fermented :: types :: identifier :: Identifier , pub public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey , pub balance : u64 , pub revision : * mut crate :: fermented :: types :: prelude :: Revision , } impl ferment_interfaces :: FFIConversion < crate :: identity :: v0 :: IdentityV0 > for IdentityV0 { unsafe fn ffi_from_const (ffi : * const IdentityV0) -> crate :: identity :: v0 :: IdentityV0 { let ffi_ref = & * ffi ; crate :: identity :: v0 :: IdentityV0 { id : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . id) , public_keys : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . public_keys) , balance : ffi_ref . balance , revision : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . revision) , } } unsafe fn ffi_to_const (obj : crate :: identity :: v0 :: IdentityV0) -> * const IdentityV0 { ferment_interfaces :: boxed (IdentityV0 { id : ferment_interfaces :: FFIConversion :: ffi_to (obj . id) , public_keys : ferment_interfaces :: FFIConversion :: ffi_to (obj . public_keys) , balance : obj . balance , revision : ferment_interfaces :: FFIConversion :: ffi_to (obj . revision) , }) } unsafe fn destroy (ffi : * mut IdentityV0) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . id) ; ; ferment_interfaces :: unbox_any (ffi_ref . public_keys) ; ; ; ferment_interfaces :: unbox_any (ffi_ref . revision) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityV0_ctor (id : * mut crate :: fermented :: types :: identifier :: Identifier , public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey , balance : u64 , revision : * mut crate :: fermented :: types :: prelude :: Revision) -> * mut IdentityV0 { ferment_interfaces :: boxed (IdentityV0 { id , public_keys , balance , revision , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityV0_destroy (ffi : * mut IdentityV0) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod identity { # [doc = "FFI-representation of the Identity"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum Identity { V0 (* mut crate :: fermented :: types :: identity :: v0 :: IdentityV0 ,) , } impl ferment_interfaces :: FFIConversion < crate :: identity :: identity :: Identity > for Identity { unsafe fn ffi_from_const (ffi : * const Identity) -> crate :: identity :: identity :: Identity { let ffi_ref = & * ffi ; match ffi_ref { Identity :: V0 (o_0 ,) => crate :: identity :: identity :: Identity :: V0 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: identity :: identity :: Identity) -> * const Identity { ferment_interfaces :: boxed (match obj { crate :: identity :: identity :: Identity :: V0 (o_0 ,) => Identity :: V0 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , }) } unsafe fn destroy (ffi : * mut Identity) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Identity { fn drop (& mut self) { unsafe { match self { Identity :: V0 (o_0 ,) => { ferment_interfaces :: unbox_any (o_0 . to_owned ()) ; ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identity_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: identity :: v0 :: IdentityV0) -> * mut Identity { ferment_interfaces :: boxed (Identity :: V0 (o_o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identity_destroy (ffi : * mut Identity) { ferment_interfaces :: unbox_any (ffi) ; } } } pub mod prelude { # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: prelude :: Revision\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Revision (u64 ,) ; impl ferment_interfaces :: FFIConversion < crate :: prelude :: Revision > for Revision { unsafe fn ffi_from_const (ffi : * const Revision) -> crate :: prelude :: Revision { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: prelude :: Revision) -> * const Revision { ferment_interfaces :: boxed (Revision (obj)) } unsafe fn destroy (ffi : * mut Revision) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Revision { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Revision_ctor (o_0 : u64) -> * mut Revision { ferment_interfaces :: boxed (Revision (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Revision_destroy (ffi : * mut Revision) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: prelude :: TimestampMillis\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct TimestampMillis (u64 ,) ; impl ferment_interfaces :: FFIConversion < crate :: prelude :: TimestampMillis > for TimestampMillis { unsafe fn ffi_from_const (ffi : * const TimestampMillis) -> crate :: prelude :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: prelude :: TimestampMillis) -> * const TimestampMillis { ferment_interfaces :: boxed (TimestampMillis (obj)) } unsafe fn destroy (ffi : * mut TimestampMillis) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TimestampMillis { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TimestampMillis_ctor (o_0 : u64) -> * mut TimestampMillis { ferment_interfaces :: boxed (TimestampMillis (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TimestampMillis_destroy (ffi : * mut TimestampMillis) { ferment_interfaces :: unbox_any (ffi) ; } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod generics { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: identity :: KeyID , pub values : * mut * mut crate :: fermented :: types :: identity :: IdentityPublicKey , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: identity :: KeyID , crate :: identity :: IdentityPublicKey > > for std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey) -> std :: collections :: BTreeMap < crate :: identity :: KeyID , crate :: identity :: IdentityPublicKey > { let ffi_ref = & * ffi ; ferment_interfaces :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | ferment_interfaces :: FFIConversion :: ffi_from (o) , | o | ferment_interfaces :: FFIConversion :: ffi_from (o)) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: identity :: KeyID , crate :: identity :: IdentityPublicKey >) -> * const std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_complex_vec (obj . keys () . cloned ()) , values : ferment_interfaces :: to_complex_vec (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey) { ferment_interfaces :: unbox_any (ffi) ; ; } } impl Drop for std_collections_Map_keys_crate_identity_KeyID_values_crate_identity_IdentityPublicKey { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } }